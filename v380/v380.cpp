// v380.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "UtlSocket.h"
#include "aes.h"

static const unsigned char mLoginData[256] = { 0x8f, 0x04, /* ........ */
0x00, 0x00, 0xfe, 0x03, 0x00, 0x00, 0x02, 0x01, /* ........ */
0x00, 0x00, 0x00, 0xb7, 0xbf, 0x0f, 0x01, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, /* .......a */
0x64, 0x6d, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00, /* dmin.... */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, /* .......I */
0x4c, 0x4f, 0x52, 0x56, 0x59, 0x5c, 0x60, 0x63, /* LORVY\`c */
0x66, 0x69, 0x6d, 0x70, 0x73, 0x76, 0x7a, 0x43, /* fimpsvzC */
0x76, 0x19, 0x12, 0x16, 0x87, 0x01, 0xac, 0xd8, /* v....... */
0x8e, 0xcd, 0x22, 0x01, 0xa1, 0x5a, 0x46, 0x00, /* .."..ZF. */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00              /* ...... */
};

static const unsigned char mStreamLogin[256] = { 0x2d, 0x01, /* ......-. */
0x00, 0x00, 0xb7, 0xbf, 0x0f, 0x01, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x14, 0x00, 0x9c, 0x27, 0x00, 0x00, /* .....'.. */
0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00              /* ...... */
};

static const unsigned char mStreamStart[256] = { 0x2f, 0x01, /* ....../. */
0x00, 0x00, 0xe9, 0x03, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00              /* ...... */
};

const uint8_t cam_select[] = { 0x01, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const uint8_t ptz_right[] = { 0xaa, 0x00, 0x00, 0x00, 0xe8, 0x03, 0xe8, 0x03, 0xe9, 0x03, 0xe8, 0x03, 0x00, 0x00, 0x01, 0x00 };
const uint8_t ptz_left[] = { 0xaa, 0x00, 0x00, 0x00, 0xe8, 0x03, 0xe8, 0x03, 0xea, 0x03, 0xe8, 0x03, 0x00, 0x00, 0x01, 0x00 };
const uint8_t ptz_up[] = { 0xaa, 0x00, 0x00, 0x00, 0xe8, 0x03, 0xe8, 0x03, 0xe8, 0x03, 0xeb, 0x03, 0x00, 0x00, 0x01, 0x00 };
const uint8_t ptz_down[] = { 0xaa, 0x00, 0x00, 0x00, 0xe8, 0x03, 0xe8, 0x03, 0xe8, 0x03, 0xec, 0x03, 0x00, 0x00, 0x01, 0x00 };
const uint8_t send_cmd[] = { 0xaa, 0x00, 0x00, 0x00, 0xe8, 0x03, 0xe8, 0x03, 0xe8, 0x03, 0xe8, 0x03, 0x00, 0x00, 0x01, 0x00 };

bool readKey(bool& up, bool& down, bool& left, bool& right);


std::string generateRandomPrintable(size_t len)
{
	char set[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890!@#$%^&*()_+-=";
	int nSet = sizeof(set);

	std::string s;
	s.resize(len);

	std::unique_ptr<char> c(new char);
	srand((unsigned int)(size_t)c.get());

	for (size_t i = 0; i < len; i++) {
		s[i] = set[rand() % nSet];
	}

	return s;
}

void GeneratePassword(std::vector<uint8_t>& output, const std::string& password)
{
	const size_t nRandomKey = 16;
	std::string randomKey = generateRandomPrintable(nRandomKey);
	const char* staticKey = "macrovideo+*#!^@";

	std::vector<uint8_t> paddedPassword;
	size_t pad = AES_BLOCKLEN - (password.size() % AES_BLOCKLEN);
	paddedPassword.resize(password.size() + pad);
	memcpy_s(paddedPassword.data(), paddedPassword.size(), password.c_str(), password.size());

	AES_ctx ctx;
	AES_init_ctx(&ctx, (uint8_t*)staticKey);

	size_t nBlock = paddedPassword.size() / AES_BLOCKLEN;
	for (size_t i = 0; i < nBlock; i++) {
		AES_ECB_encrypt(&ctx, paddedPassword.data() + i * AES_BLOCKLEN);
	}

	AES_ctx ctx2;
	AES_init_ctx(&ctx2, (uint8_t*)randomKey.data());
	for (size_t i = 0; i < nBlock; i++) {
		AES_ECB_encrypt(&ctx2, paddedPassword.data() + i * AES_BLOCKLEN);
	}

	output.resize(nRandomKey + nBlock * AES_BLOCKLEN);
	memcpy_s(output.data(), output.size(), randomKey.c_str(), nRandomKey);
	memcpy_s(output.data() + nRandomKey, output.size() - nRandomKey, paddedPassword.data(), paddedPassword.size());
}

void printHelp(FILE* f)
{
	fprintf(f, "Usage example:\n");
	fprintf(f, "  v380 -u admin -p password -ip 192.168.1.2 -port 8800\n");
	fprintf(f, "  v380 -p password -addr 192.168.1.2 | ffplay -vf \"setpts = N / (25 * TB)\" -i -\n");
	fprintf(f, "\n");
	fprintf(f, "OPTIONS:\n");
	fprintf(f, "  -u              username         (default admin)\n");
	fprintf(f, "  -p              password\n");
	fprintf(f, "  -addr           camera IP/address\n");
	fprintf(f, "  -port           camera port      (default 8800)\n");
	fprintf(f, "  --enable-ptz=0  Disable pan-tilt-zoom via keyboard press\n");
	fprintf(f, "  -h              Show this help\n");
}

int main(int argc, const char* argv[])
{
	int retry = 0;

	std::string ip = "";
	std::string port = "8800";
	std::string username = "admin";
	std::string password = "password";
	bool enable_ptz = true;
	bool show_help = false;

	for (int i = 0; i < argc; i++)
	{
		if ((_stricmp(argv[i], "-u") == 0) && ((i + 1) < argc))
		{
			username = argv[i + 1];
		}
		else if ((_stricmp(argv[i], "-p") == 0) && ((i + 1) < argc))
		{
			password = argv[i + 1];
		}
		else if ((_stricmp(argv[i], "-addr") == 0) && ((i + 1) < argc))
		{
			ip = argv[i + 1];
		}
		else if ((_stricmp(argv[i], "-port") == 0) && ((i + 1) < argc))
		{
			port = argv[i + 1];
		}
		else if ((_stricmp(argv[i], "--enable-ptz=0") == 0))
		{
			enable_ptz = false;
		}
		else if ((_stricmp(argv[i], "-h") == 0) || (_stricmp(argv[i], "--help") == 0))
		{
			show_help = true;
		}
	}

	if (ip.empty()) {
		fprintf(stderr, "Camera address not set\n\n");
		printHelp(stderr);
		return 1;
	}

	if (port.empty()) {
		fprintf(stderr, "Camera port not set\n\n");
		printHelp(stderr);
		return 1;
	}

	if (show_help) {
		printHelp(stdout);
		return 0;
	}

	std::vector<uint8_t> ptzcmd(send_cmd, send_cmd + sizeof(send_cmd));

#ifdef _WIN32
	_setmode(_fileno(stdout), O_BINARY);
#endif

	while (retry++ < 5)
	{
		try
		{
			UtlSocket socketAuth;
			UtlSocket socketStream;

			std::vector<uint8_t> buf;
			std::vector<uint8_t> hdr;
			std::vector<uint8_t> vframe;

			buf.reserve(500);
			hdr.reserve(12);
			vframe.reserve(8192);

			socketAuth.Connect(ip, port);

			std::vector<uint8_t> pw;
			GeneratePassword(pw, password);

			buf.insert(buf.end(), mLoginData, mLoginData + sizeof(mLoginData));
			memcpy_s(buf.data() + 49, 32, username.c_str(), username.size());
			memcpy_s(buf.data() + 49 + 32, 32, pw.data(), pw.size());

			socketAuth.Send(buf);
			socketAuth.Recv(buf, 256);
			socketAuth.Close();

			socketStream.Connect(ip, port);
			socketStream.DisableNagle();

			uint32_t authTicket = *(uint32_t*)(buf.data() + 13); // there is 2 bytes changed, but copy uint32 size for safety
			buf.clear();
			buf.insert(buf.end(), mStreamLogin, mStreamLogin + sizeof(mStreamLogin));
			*(uint32_t*)(buf.data() + 14) = authTicket;

			socketStream.Send(buf);
			//socketStream.Recv(buf, 256);

			buf.clear();
			socketStream.Send(mStreamStart, sizeof(mStreamStart));
			socketStream.Recv(buf, 256);

			bool exitloop = false;
			while (socketStream.Recv(hdr, 12) >= 12 && !exitloop)
			{
				switch (hdr[0])
				{
				case 0x7f:
				{
					uint16_t totalFrame = *(uint16_t*)&hdr[3];
					uint16_t curFrame = *(uint16_t*)&hdr[5];
					uint16_t len = *(uint16_t*)&hdr[7];
					uint8_t type = hdr[1];

					if (len > 500 || !totalFrame || curFrame > totalFrame) {
						fprintf(stderr, "Sanity check failed, should bail out\n");
						break;
					}

					buf.resize(len);
					int n = 0;
					while (n < len) {
						n += socketStream.Recv(buf.data() + n, len - n);
					}

					retry = 0;

					switch (type)
					{
					case 0x00:
						vframe.insert(vframe.end(), buf.begin(), buf.end());
						if (curFrame == totalFrame - 1) {
							fwrite(vframe.data(), 1, vframe.size(), stdout);
							fflush(stdout);
							vframe.clear();
						}
						break;

					case 0x01:
						// Video
						vframe.insert(vframe.end(), buf.begin(), buf.end());
						if (curFrame == totalFrame - 1) {
							fwrite(vframe.data(), 1, vframe.size(), stdout);
							fflush(stdout);
							vframe.clear();
						}
						break;

					case 0x16:
						// Audio
						// sox -t ima -r 8000 -e ms-adpcm C:\Users\Syahmi\Desktop\v380\stream.adts -e signed-integer -b 16 out.wav

						//vframe.insert(vframe.end(), buf.begin(), buf.end());
						//if (curFrame == totalFrame - 1) {
						//	fwrite(vframe.data(), 1, vframe.size(), stdout);
						//}
						break;
					}

					break;
				}
				case 0x1f:
					// Not sure what this does yet
					fprintf(stderr, "Unparsed 0x1f data\n");
					break;
				case 0x6f:
					Sleep(20);
					break;
				default:
					exitloop = true;
					break;
				}

				bool up, dn, l, r;
				if (enable_ptz && readKey(up, dn, l, r)) {
					ptzcmd[8] = 0xe8;
					ptzcmd[10] = 0xe8;
					if (up) ptzcmd[10] = 0xeb;
					if (dn) ptzcmd[10] = 0xec;
					if (l) ptzcmd[8] = 0xea;
					if (r) ptzcmd[8] = 0xe9;
					socketStream.Send(ptzcmd);
				}
			}
		}
		catch (const std::exception& ex)
		{
			fprintf(stderr, "%s", ex.what());
		}
	}

    return 0;
}

bool readKey(bool& up, bool& down, bool& left, bool& right)
{
	bool ret = false;

	up = false;
	down = false;
	left = false;
	right = false;

#ifdef _WIN32
	if (GetForegroundWindow() == GetConsoleWindow())
	{
		if ((GetAsyncKeyState(VK_RIGHT) & 0x8000) != 0)
		{
			right = true;
			ret = true;
		}
		if ((GetAsyncKeyState(VK_LEFT) & 0x8000) != 0)
		{
			left = true;
			ret = true;
		}
		if ((GetAsyncKeyState(VK_UP) & 0x8000) != 0)
		{
			up = true;
			ret = true;
		}
		if ((GetAsyncKeyState(VK_DOWN) & 0x8000) != 0)
		{
			down = true;
			ret = true;
		}
	}
#endif

	return ret;
}